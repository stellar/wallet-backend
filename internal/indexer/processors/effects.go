// EffectsProcessor processes Stellar transaction effects and extracts state changes for account properties.
// It handles signers, thresholds, flags, home domains, data entries, and sponsorship relationships.
package processors

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"time"

	"github.com/stellar/go/ingest"
	effects "github.com/stellar/go/processors/effects"
	operation "github.com/stellar/go/processors/operation"
	"github.com/stellar/go/toid"
	"github.com/stellar/go/xdr"

	"github.com/stellar/wallet-backend/internal/indexer/types"
)

var (
	// thresholdToReasonMap maps Stellar effect detail field names to our internal state change reasons
	// for account signature threshold updates (low, medium, high threshold changes)
	thresholdToReasonMap = map[string]types.StateChangeReason{
		"low_threshold":  types.StateChangeReasonLow,
		"med_threshold":  types.StateChangeReasonMedium,
		"high_threshold": types.StateChangeReasonHigh,
	}
	// signerEffectToReasonMap maps Stellar signer effect types to our internal state change reasons
	// for tracking when signers are added, removed, or updated on accounts
	signerEffectToReasonMap = map[int32]types.StateChangeReason{
		int32(effects.EffectSignerCreated): types.StateChangeReasonAdd,
		int32(effects.EffectSignerRemoved): types.StateChangeReasonRemove,
		int32(effects.EffectSignerUpdated): types.StateChangeReasonUpdate,
	}
	// accountFlags defines the Stellar account flags we track for authorization states
	accountFlags = []string{
		"auth_required_flag",
		"auth_revocable_flag",
		"auth_immutable_flag",
		"auth_clawback_enabled_flag",
	}
	// trustlineFlags defines the Stellar trustline flags we track for asset authorization states
	trustlineFlags = []string{
		"authorized_flag",
		"authorized_to_maintain_liabilites",
		"clawback_enabled_flag",
	}
	ErrBeforeAccountNotFound = errors.New("before account not found")
)

// EffectsProcessor processes transaction effects generated by horizon's effects processor and converts them into our internal state changes.
// It focuses on account state changes like signers, thresholds, flags, and sponsorship relationships.
type EffectsProcessor struct {
	networkPassphrase string
}

// NewEffectsProcessor creates a new effects processor for the specified Stellar network.
func NewEffectsProcessor(networkPassphrase string) *EffectsProcessor {
	return &EffectsProcessor{
		networkPassphrase: networkPassphrase,
	}
}

// ProcessTransaction extracts effects from a Stellar operation and converts them into state changes.
// It processes account state changes like signer modifications, threshold updates, flag changes,
// home domain updates, data entry changes, and sponsorship relationship modifications.
// Returns a slice of state changes representing various account state changes.
func (p *EffectsProcessor) ProcessTransaction(ctx context.Context, tx ingest.LedgerTransaction, op xdr.Operation, opIdx uint32) ([]types.StateChange, error) {
	ledgerCloseTime := tx.Ledger.LedgerCloseTime()
	ledgerNumber := tx.Ledger.LedgerSequence()
	opID := toid.New(int32(ledgerNumber), int32(tx.Index), int32(opIdx)).ToInt64()
	txHash := tx.Result.TransactionHash.HexString()

	opWrapper := operation.TransactionOperationWrapper{
		Index:          opIdx,
		LedgerSequence: tx.Ledger.LedgerSequence(),
		LedgerClosed:   time.Unix(tx.Ledger.LedgerCloseTime(), 0),
		Transaction:    tx,
		Operation:      op,
		Network:        p.networkPassphrase,
	}

	// Extract effects from the operation using Stellar SDK
	effectOutputs, err := effects.Effects(&opWrapper)
	if err != nil {
		return nil, fmt.Errorf("processing effects: %w", err)
	}

	// Get operation changes to access old values when needed
	changes, err := tx.GetOperationChanges(opIdx)
	if err != nil {
		return nil, fmt.Errorf("getting operation changes: %w", err)
	}

	stateChanges := make([]types.StateChange, 0)
	masterBuilder := NewStateChangeBuilder(ledgerNumber, ledgerCloseTime, txHash).WithOperationID(opID)
	// Process each effect and convert to our internal state change representation
	for _, effect := range effectOutputs {
		changeBuilder := masterBuilder.Clone().WithAccount(effect.Address)

		effectType := effects.EffectType(effect.Type)
		// Process different types of effects based on what account property they modify
		//exhaustive:ignore
		switch effectType {
		// Signer effects: track changes to account signers (add/remove/update signer keys and weights)
		case effects.EffectSignerCreated, effects.EffectSignerRemoved, effects.EffectSignerUpdated:
			changeBuilder = changeBuilder.
				WithCategory(types.StateChangeCategorySigner).
				WithReason(signerEffectToReasonMap[effect.Type])
			signerChanges, err := p.parseSigners(changeBuilder, &effect, effectType, changes)
			if err != nil {
				return nil, fmt.Errorf("processing signer effects: %w", err)
			}
			stateChanges = append(stateChanges, signerChanges...)

		// Threshold effects: track changes to account signature thresholds (low/medium/high)
		case effects.EffectAccountThresholdsUpdated:
			changeBuilder = changeBuilder.WithCategory(types.StateChangeCategorySignatureThreshold)
			thresholdChanges, err := p.parseThresholds(changeBuilder, &effect, changes)
			if err != nil {
				return nil, fmt.Errorf("processing threshold effects: %w", err)
			}
			stateChanges = append(stateChanges, thresholdChanges...)

		// Flag effects: track changes to account authorization flags
		case effects.EffectAccountFlagsUpdated:
			changeBuilder = changeBuilder.WithCategory(types.StateChangeCategoryFlags)
			stateChanges = append(stateChanges, p.parseFlags(accountFlags, changeBuilder, &effect)...)

		// Home domain effects: track changes to account home domain metadata
		case effects.EffectAccountHomeDomainUpdated:
			keyValueMap := p.parseKeyValue([]string{"home_domain"}, &effect)
			stateChanges = append(stateChanges, changeBuilder.
				WithCategory(types.StateChangeCategoryMetadata).
				WithReason(types.StateChangeReasonHomeDomain).
				WithKeyValue(keyValueMap).
				Build())

		// Trustline flag effects: track changes to trustline authorization flags
		case effects.EffectTrustlineFlagsUpdated:
			changeBuilder = changeBuilder.WithCategory(types.StateChangeCategoryTrustlineFlags)
			stateChanges = append(stateChanges, p.parseFlags(trustlineFlags, changeBuilder, &effect)...)

		// Data entry effects: track changes to account data entries (key-value storage)
		case effects.EffectDataCreated, effects.EffectDataRemoved, effects.EffectDataUpdated:
			keyValueMap := p.parseKeyValue([]string{"name", "value"}, &effect)
			stateChanges = append(stateChanges, changeBuilder.
				WithCategory(types.StateChangeCategoryMetadata).
				WithReason(types.StateChangeReasonDataEntry).
				WithKeyValue(keyValueMap).
				Build())

		// Sponsorship effects: track changes to sponsorship relationships for various ledger entries
		// These effects occur when accounts sponsor or stop sponsoring other accounts' reserves
		case effects.EffectAccountSponsorshipCreated, effects.EffectAccountSponsorshipRemoved, effects.EffectAccountSponsorshipUpdated,
			effects.EffectClaimableBalanceSponsorshipCreated, effects.EffectClaimableBalanceSponsorshipRemoved, effects.EffectClaimableBalanceSponsorshipUpdated,
			effects.EffectDataSponsorshipCreated, effects.EffectDataSponsorshipRemoved, effects.EffectDataSponsorshipUpdated,
			effects.EffectSignerSponsorshipCreated, effects.EffectSignerSponsorshipRemoved, effects.EffectSignerSponsorshipUpdated,
			effects.EffectTrustlineSponsorshipCreated, effects.EffectTrustlineSponsorshipRemoved, effects.EffectTrustlineSponsorshipUpdated:

			sponsorshipChanges := p.processSponsorshipEffect(effectType, effect, changeBuilder.Clone())
			stateChanges = append(stateChanges, sponsorshipChanges...)

		default:
			// Skip effects we don't track (e.g., balance changes, trades, etc.)
			continue
		}
	}

	return stateChanges, nil
}

// processSponsorshipEffect handles sponsorship-related effects and creates appropriate state changes.
// Sponsorship in Stellar allows one account to pay the base reserves for another account's ledger entries.
// This function creates state changes for both the sponsor and the sponsored account/entry.
func (p *EffectsProcessor) processSponsorshipEffect(effectType effects.EffectType, effect effects.EffectOutput, baseBuilder *StateChangeBuilder) []types.StateChange {
	baseBuilder = baseBuilder.WithCategory(types.StateChangeCategorySponsorship)

	var sponsorChanges []types.StateChange
	var targetChange types.StateChange

	// Handle different sponsorship effect types and create appropriate state changes
	//exhaustive:ignore
	switch effectType {
	// Created cases: when sponsorship relationships are established
	case effects.EffectAccountSponsorshipCreated, effects.EffectClaimableBalanceSponsorshipCreated,
		effects.EffectDataSponsorshipCreated, effects.EffectSignerSponsorshipCreated, effects.EffectTrustlineSponsorshipCreated:
		sponsor := effect.Details["sponsor"].(string)
		sponsorChanges = append(sponsorChanges, p.createSponsorChange(types.StateChangeReasonSet, baseBuilder.Clone(), sponsor, effect.Address))
		targetChange = p.createTargetSponsorshipChange(types.StateChangeReasonSet, sponsor, effectType, effect, baseBuilder.Clone())

	// Removed cases: when sponsorship relationships are terminated
	case effects.EffectAccountSponsorshipRemoved, effects.EffectClaimableBalanceSponsorshipRemoved,
		effects.EffectDataSponsorshipRemoved, effects.EffectSignerSponsorshipRemoved, effects.EffectTrustlineSponsorshipRemoved:
		formerSponsor := effect.Details["former_sponsor"].(string)
		sponsorChanges = append(sponsorChanges, p.createSponsorChange(types.StateChangeReasonRevoke, baseBuilder.Clone(), formerSponsor, effect.Address))
		targetChange = p.createTargetSponsorshipChange(types.StateChangeReasonRevoke, formerSponsor, effectType, effect, baseBuilder.Clone())

	// Updated cases: when sponsorship relationships are transferred from one sponsor to another
	case effects.EffectAccountSponsorshipUpdated, effects.EffectClaimableBalanceSponsorshipUpdated,
		effects.EffectDataSponsorshipUpdated, effects.EffectSignerSponsorshipUpdated, effects.EffectTrustlineSponsorshipUpdated:
		newSponsor := effect.Details["new_sponsor"].(string)
		formerSponsor := effect.Details["former_sponsor"].(string)
		sponsorChanges = append(sponsorChanges,
			p.createSponsorChange(types.StateChangeReasonSet, baseBuilder.Clone(), newSponsor, effect.Address),
			p.createSponsorChange(types.StateChangeReasonRemove, baseBuilder.Clone(), formerSponsor, effect.Address),
		)
		targetBuilder := baseBuilder.Clone().WithKeyValue(p.parseKeyValue([]string{"former_sponsor"}, &effect))
		targetChange = p.createTargetSponsorshipChange(types.StateChangeReasonUpdate, newSponsor, effectType, effect, targetBuilder)
	}

	return append(sponsorChanges, targetChange)
}

// createSponsorChange creates a state change for the sponsor account in a sponsorship relationship.
// This tracks when an account starts, stops, or changes its sponsorship of another account's reserves.
func (p *EffectsProcessor) createSponsorChange(reason types.StateChangeReason, builder *StateChangeBuilder, sponsor string, targetAccountID string) types.StateChange {
	return builder.
		WithReason(reason).
		WithAccount(sponsor).
		WithTargetAccountID(targetAccountID).
		Build()
}

// createTargetSponsorshipChange creates a state change for the sponsored account or ledger entry.
// This tracks the target side of sponsorship relationships, including specific entry details like claimable balance IDs.
func (p *EffectsProcessor) createTargetSponsorshipChange(reason types.StateChangeReason, sponsor string, effectType effects.EffectType, effect effects.EffectOutput, builder *StateChangeBuilder) types.StateChange {
	builder = builder.WithReason(reason).WithSponsor(sponsor)

	// Add specific identifiers based on the type of sponsored reserve
	//exhaustive:ignore
	switch effectType {
	// For claimable balance sponsorship, include the balance ID
	case effects.EffectClaimableBalanceSponsorshipCreated, effects.EffectClaimableBalanceSponsorshipUpdated, effects.EffectClaimableBalanceSponsorshipRemoved:
		builder = builder.WithClaimableBalance(effect.Details["balance_id"].(string))
	// For trustline sponsorship, include liquidity pool ID if applicable
	case effects.EffectTrustlineSponsorshipCreated, effects.EffectTrustlineSponsorshipUpdated, effects.EffectTrustlineSponsorshipRemoved:
		if lpID, ok := effect.Details["liquidity_pool_id"]; ok {
			builder = builder.WithLiquidityPool(lpID.(string))
		}
	// For signer sponsorship, include the signer key
	case effects.EffectSignerSponsorshipCreated, effects.EffectSignerSponsorshipUpdated, effects.EffectSignerSponsorshipRemoved:
		builder = builder.WithSigner(effect.Details["signer"].(string), map[string]any{
			"new": 0,
		})
	}

	return builder.Build()
}

// parseKeyValue extracts specified key-value pairs from effect details.
// This is used to capture metadata like home domain values or data entry names and values.
func (p *EffectsProcessor) parseKeyValue(keys []string, effect *effects.EffectOutput) map[string]any {
	keyValueMap := map[string]any{}
	for _, key := range keys {
		if value, ok := effect.Details[key]; ok {
			keyValueMap[key] = value
		}
	}
	return keyValueMap
}

// parseFlags processes flag-related effects and creates separate state changes for set and cleared flags.
// Stellar flags can be either set (true) or cleared (false), and we track each change separately.
func (p *EffectsProcessor) parseFlags(flags []string, changeBuilder *StateChangeBuilder, effect *effects.EffectOutput) []types.StateChange {
	setFlags := make(map[string]any)
	clearFlags := make(map[string]any)
	for _, flag := range flags {
		if value, ok := effect.Details[flag]; ok {
			if value == true {
				setFlags[flag] = true
			} else {
				clearFlags[flag] = false
			}
		}
	}

	// Create separate state changes for flags being set vs cleared
	changes := make([]types.StateChange, 0)
	if len(setFlags) > 0 {
		changes = append(changes, changeBuilder.
			Clone().
			WithReason(types.StateChangeReasonSet).
			WithFlags(setFlags).
			Build())
	}
	if len(clearFlags) > 0 {
		changes = append(changes, changeBuilder.
			Clone().
			WithReason(types.StateChangeReasonClear).
			WithFlags(clearFlags).
			Build())
	}

	return changes
}

func (p *EffectsProcessor) parseSigners(changeBuilder *StateChangeBuilder, effect *effects.EffectOutput, effectType effects.EffectType, changes []ingest.Change) ([]types.StateChange, error) {
	signerPublicKey := effect.Details["public_key"].(string)
	weight, err := ConvertToInt32(effect.Details["weight"])
	if err != nil {
		return nil, fmt.Errorf("converting weight for signer created effect: %w", err)
	}

	//exhaustive:ignore
	switch effectType {
	case effects.EffectSignerCreated:
		changeBuilder = changeBuilder.WithSigner(
			signerPublicKey,
			map[string]any{
				"new": weight,
			},
		)
	case effects.EffectSignerUpdated, effects.EffectSignerRemoved:
		var oldSignerSummary map[string]int32
		prevAccountState, err := p.getPrevAccountState(effect, changes)
		if err != nil {
			return nil, fmt.Errorf("getting previous changes for account: %s: %w", effect.Address, err)
		}
		oldSignerSummary = prevAccountState.SignerSummary()

		weights := map[string]any{
			"old": oldSignerSummary[signerPublicKey],
		}
		if effectType == effects.EffectSignerUpdated {
			weights["new"] = weight
		}
		changeBuilder = changeBuilder.WithSigner(signerPublicKey, weights)
	}
	return []types.StateChange{changeBuilder.Build()}, nil
}

// parseThresholds processes threshold-related effects and creates state changes for each threshold type.
// Stellar accounts have low, medium, and high signature thresholds that control what operations require how many signatures.
// It extracts both old and new threshold values from the ledger changes to provide complete context.
func (p *EffectsProcessor) parseThresholds(changeBuilder *StateChangeBuilder, effect *effects.EffectOutput, changes []ingest.Change) ([]types.StateChange, error) {
	// Find the account entry change to get old threshold values
	prevAccountState, err := p.getPrevAccountState(effect, changes)
	if err != nil {
		return nil, fmt.Errorf("getting previous changes for account: %s: %w", effect.Address, err)
	}

	// Create a separate state change for each threshold that was modified
	thresholdChanges := make([]types.StateChange, 0)
	for threshold, reason := range thresholdToReasonMap {
		if value, ok := effect.Details[threshold]; ok {
			// Convert XDR threshold value to string for storage
			thresholdValue := strconv.FormatInt(int64(value.(xdr.Uint32)), 10)

			// Create threshold details with both old and new values
			thresholdDetails := map[string]any{
				"new": thresholdValue,
			}

			// Add old threshold value
			var oldValue string
			switch threshold {
			case "low_threshold":
				oldValue = strconv.FormatInt(int64(prevAccountState.Thresholds[1]), 10) // Index 1: Low threshold
			case "med_threshold":
				oldValue = strconv.FormatInt(int64(prevAccountState.Thresholds[2]), 10) // Index 2: Medium threshold
			case "high_threshold":
				oldValue = strconv.FormatInt(int64(prevAccountState.Thresholds[3]), 10) // Index 3: High threshold
			}
			thresholdDetails["old"] = oldValue

			thresholdChanges = append(thresholdChanges, changeBuilder.
				Clone().
				WithReason(reason).
				WithThresholds(thresholdDetails).
				Build())
		}
	}
	return thresholdChanges, nil
}

func (p *EffectsProcessor) getPrevAccountState(effect *effects.EffectOutput, changes []ingest.Change) (xdr.AccountEntry, error) {
	for _, change := range changes {
		if change.Type != xdr.LedgerEntryTypeAccount {
			continue
		}
		if change.Pre != nil {
			beforeAccount := change.Pre.Data.MustAccount()
			if beforeAccount.AccountId.Address() == effect.Address {
				return beforeAccount, nil
			}
		}
	}
	return xdr.AccountEntry{}, ErrBeforeAccountNotFound
}
