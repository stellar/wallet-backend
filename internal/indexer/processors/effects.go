// EffectsProcessor processes Stellar transaction effects and extracts state changes for account properties.
// It handles signers, thresholds, flags, home domains, data entries, and sponsorship relationships.
package processors

import (
	"context"
	"encoding/base64"
	"fmt"
	"strconv"
	"time"

	"github.com/stellar/go/ingest"
	operation_processor "github.com/stellar/go/processors/operation"
	"github.com/stellar/go/xdr"

	"github.com/stellar/go/support/log"

	"github.com/stellar/wallet-backend/internal/indexer/types"
)

const (
	// Threshold array indices for accessing account thresholds
	lowThresholdIndex                       = 1
	medThresholdIndex                       = 2
	highThresholdIndex                      = 3
	AuthorizedFlagName                      = "authorized"
	AuthorizedRequiredFlagName              = "auth_required"
	AuthorizedRevocableFlagName             = "auth_revocable"
	AuthorizedImmutableFlagName             = "auth_immutable"
	AuthorizedClawbackEnabledFlagName       = "auth_clawback_enabled"
	ClawbackEnabledFlagName                 = "clawback_enabled"
	AuthorizedToMaintainLiabilitiesFlagName = "authorized_to_maintain_liabilities"
)

var (
	// thresholdToReasonMap maps Stellar effect detail field names to our internal state change reasons
	// for account signature threshold updates (low, medium, high threshold changes)
	thresholdToReasonMap = map[string]types.StateChangeReason{
		"low_threshold":  types.StateChangeReasonLow,
		"med_threshold":  types.StateChangeReasonMedium,
		"high_threshold": types.StateChangeReasonHigh,
	}
	// signerEffectToReasonMap maps Stellar signer effect types to our internal state change reasons
	// for tracking when signers are added, removed, or updated on accounts
	signerEffectToReasonMap = map[int32]types.StateChangeReason{
		int32(EffectSignerCreated): types.StateChangeReasonAdd,
		int32(EffectSignerRemoved): types.StateChangeReasonRemove,
		int32(EffectSignerUpdated): types.StateChangeReasonUpdate,
	}
	// accountFlags defines the Stellar account flags we track for authorization states
	accountFlags = []string{
		"auth_required_flag",
		"auth_revocable_flag",
		"auth_immutable_flag",
		"auth_clawback_enabled_flag",
	}
	// trustlineFlags defines the Stellar trustline flags we track for asset authorization states
	trustlineFlags = []string{
		"authorized_flag",
		"authorized_to_maintain_liabilites",
		"clawback_enabled_flag",
	}
)

// EffectsProcessor processes transaction effects generated by horizon's effects processor and converts them into our internal state changes.
// It focuses on account state changes like signers, thresholds, flags, and sponsorship relationships.
type EffectsProcessor struct {
	networkPassphrase string
	metricsService    MetricsServiceInterface
}

// NewEffectsProcessor creates a new effects processor for the specified Stellar network.
func NewEffectsProcessor(networkPassphrase string, metricsService MetricsServiceInterface) *EffectsProcessor {
	return &EffectsProcessor{
		networkPassphrase: networkPassphrase,
		metricsService:    metricsService,
	}
}

func (p *EffectsProcessor) Name() string {
	return "effects"
}

// ProcessOperation extracts effects from a Stellar operation and converts them into state changes.
// It processes account state changes like signer modifications, threshold updates, flag changes,
// home domain updates, data entry changes, and sponsorship relationship modifications.
// Returns a slice of state changes representing various account state changes.
func (p *EffectsProcessor) ProcessOperation(_ context.Context, opWrapper *operation_processor.TransactionOperationWrapper) ([]types.StateChange, error) {
	startTime := time.Now()
	defer func() {
		if p.metricsService != nil {
			duration := time.Since(startTime).Seconds()
			p.metricsService.ObserveStateChangeProcessingDuration("EffectsProcessor", duration)
		}
	}()

	ledgerCloseTime := opWrapper.Transaction.Ledger.LedgerCloseTime()
	ledgerNumber := opWrapper.Transaction.Ledger.LedgerSequence()
	txHash := opWrapper.Transaction.Result.TransactionHash.HexString()
	txID := opWrapper.Transaction.ID()

	// Extract effects from the operation using Stellar SDK
	effectOutputs, err := Effects(opWrapper)
	if err != nil {
		return nil, fmt.Errorf("getting effects for tx: %s, opID: %d, err: %w", txHash, opWrapper.ID(), err)
	}

	// Get operation changes to access old values when needed
	changes, err := opWrapper.Transaction.GetOperationChanges(opWrapper.Index)
	if err != nil {
		return nil, fmt.Errorf("getting operation changes for tx: %s, opID: %d, err: %w", txHash, opWrapper.ID(), err)
	}

	var stateChanges []types.StateChange
	masterBuilder := NewStateChangeBuilder(ledgerNumber, ledgerCloseTime, txHash, txID, p.metricsService).WithOperationID(opWrapper.ID())
	// Process each effect and convert to our internal state change representation
	for _, effect := range effectOutputs {
		changeBuilder := masterBuilder.Clone().WithAccount(effect.Address)

		effectType := EffectType(effect.Type)
		// Process different types of effects based on what account property they modify
		//exhaustive:ignore
		switch effectType {
		// Signer effects: track changes to account signers (add/remove/update signer keys and weights)
		case EffectSignerCreated, EffectSignerRemoved, EffectSignerUpdated:
			changeBuilder = changeBuilder.
				WithCategory(types.StateChangeCategorySigner).
				WithReason(signerEffectToReasonMap[effect.Type])
			signerChanges, err := p.parseSigners(changeBuilder, &effect, effectType, changes)
			if err != nil {
				log.Debugf("processor: %s: failed to parse signer effects: effectType: %s, address: %s, txHash: %s, opID: %d, err: %v", p.Name(), effect.TypeString, effect.Address, txHash, opWrapper.ID(), err)
				continue
			}
			stateChanges = append(stateChanges, signerChanges...)

		// Threshold effects: track changes to account signature thresholds (low/medium/high)
		case EffectAccountThresholdsUpdated:
			changeBuilder = changeBuilder.WithCategory(types.StateChangeCategorySignatureThreshold)
			stateChanges = append(stateChanges, p.parseThresholds(changeBuilder, &effect, changes)...)

		// Flag effects: track changes to account authorization flags
		case EffectAccountFlagsUpdated:
			changeBuilder = changeBuilder.WithCategory(types.StateChangeCategoryFlags)
			stateChanges = append(stateChanges, p.parseFlags(accountFlags, changeBuilder, &effect)...)

		// Home domain effects: track changes to account home domain metadata
		case EffectAccountHomeDomainUpdated:
			keyValueMap := p.parseKeyValue(&effect, effectType, changes, "home_domain")
			stateChanges = append(stateChanges, changeBuilder.
				WithCategory(types.StateChangeCategoryMetadata).
				WithReason(types.StateChangeReasonHomeDomain).
				WithKeyValue(keyValueMap).
				Build())

		// Trustline flag effects: track changes to trustline authorization flags
		case EffectTrustlineFlagsUpdated:
			changeBuilder = changeBuilder.WithCategory(types.StateChangeCategoryBalanceAuthorization)
			// Note: The Stellar SDK sets effect.Address to the operation source (issuer),
			// but the trustline flags are actually being set on the trustor's account.
			// We need to extract the trustor address from effect.Details instead.
			if trustorAddr, err := safeStringFromDetails(effect.Details, "trustor"); err == nil {
				changeBuilder = changeBuilder.Clone().WithAccount(trustorAddr)
			}
			// Build the asset contract ID from the trustline effect
			_, _, assetContractID, err := p.buildAssetContractIDFromTrustlineEffect(&effect)
			if err != nil {
				log.Debugf("processor: %s: failed to build asset contract ID from trustline effect: effectType: %s, address: %s, txHash: %s, opID: %d, err: %v", p.Name(), effect.TypeString, effect.Address, txHash, opWrapper.ID(), err)
				continue
			}
			changeBuilder = changeBuilder.WithToken(assetContractID)
			stateChanges = append(stateChanges, p.parseFlags(trustlineFlags, changeBuilder, &effect)...)

		// Change trust effects
		case EffectTrustlineCreated, EffectTrustlineRemoved, EffectTrustlineUpdated:
			changeBuilder = changeBuilder.WithCategory(types.StateChangeCategoryTrustline)
			trustlineChange, err := p.parseTrustline(changeBuilder, &effect, effectType, changes)
			if err != nil {
				log.Debugf("processor: %s: failed to parse trustline effect: effectType: %s, address: %s, txHash: %s, opID: %d, err: %v", p.Name(), effect.TypeString, effect.Address, txHash, opWrapper.ID(), err)
				continue
			}
			stateChanges = append(stateChanges, trustlineChange)

			// Generate balance authorization state change for new trustline.
			// We will extract the authorization flags directly from the trustline entry in the changes.
			if effectType == EffectTrustlineCreated {
				authChanges, err := p.generateBalanceAuthorizationForNewTrustline(changeBuilder, &effect, changes)
				if err != nil {
					log.Debugf("processor: %s: failed to generate balance authorization for new trustline: effectType: %s, address: %s, txHash: %s, opID: %d, err: %v", p.Name(), effect.TypeString, effect.Address, txHash, opWrapper.ID(), err)
					continue
				}
				stateChanges = append(stateChanges, authChanges)
			}

		// Data entry effects: track changes to account data entries (key-value storage)
		case EffectDataCreated, EffectDataRemoved, EffectDataUpdated:
			keyValueMap := p.parseKeyValue(&effect, effectType, changes, "name")
			stateChanges = append(stateChanges, changeBuilder.
				WithCategory(types.StateChangeCategoryMetadata).
				WithReason(types.StateChangeReasonDataEntry).
				WithKeyValue(keyValueMap).
				Build())

		// Sponsorship effects: track changes to sponsorship relationships for various ledger entries
		// These effects occur when accounts sponsor or stop sponsoring other accounts' reserves
		case EffectAccountSponsorshipCreated, EffectAccountSponsorshipRemoved, EffectAccountSponsorshipUpdated,
			EffectClaimableBalanceSponsorshipCreated, EffectClaimableBalanceSponsorshipRemoved, EffectClaimableBalanceSponsorshipUpdated,
			EffectDataSponsorshipCreated, EffectDataSponsorshipRemoved, EffectDataSponsorshipUpdated,
			EffectSignerSponsorshipCreated, EffectSignerSponsorshipRemoved, EffectSignerSponsorshipUpdated,
			EffectTrustlineSponsorshipCreated, EffectTrustlineSponsorshipRemoved, EffectTrustlineSponsorshipUpdated:

			sponsorshipChanges, err := p.processSponsorshipEffect(effectType, effect, changeBuilder.Clone())
			if err != nil {
				log.Debugf("processor: %s: failed to process sponsorship effect: effectType: %s, address: %s, txHash: %s, opID: %d, err: %v", p.Name(), effect.TypeString, effect.Address, txHash, opWrapper.ID(), err)
				continue
			}
			stateChanges = append(stateChanges, sponsorshipChanges...)

		default:
			// Skip effects we don't track (e.g., balance changes, trades, etc.)
			continue
		}
	}

	return stateChanges, nil
}

// processSponsorshipEffect handles sponsorship-related effects and creates appropriate state changes.
// Sponsorship in Stellar allows one account to pay the base reserves for another account's ledger entries.
// This creates TWO state changes for all sponsorship types:
// 1. State change for the sponsoring account (with SponsoredAccountID set to effect.Address)
// 2. State change for the sponsored account (effect.Address, with SponsorAccountID set)
// For non-account sponsorships (trustline, data, claimable balance, signer), both state changes
// include keyValue containing entity-specific details (asset, data_name, balance_id, signer).
func (p *EffectsProcessor) processSponsorshipEffect(effectType EffectType, effect EffectOutput, baseBuilder *StateChangeBuilder) ([]types.StateChange, error) {
	baseBuilder = baseBuilder.WithCategory(types.StateChangeCategoryReserves)

	var sponsorChanges []types.StateChange

	// Determine if this is account sponsorship or other entity sponsorship
	isAccountSponsorship := effectType == EffectAccountSponsorshipCreated ||
		effectType == EffectAccountSponsorshipUpdated ||
		effectType == EffectAccountSponsorshipRemoved

	// Extract keyValue for non-account sponsorships, nil for account sponsorships
	var keyValue map[string]any
	if !isAccountSponsorship {
		keyValue = p.extractSponsorshipKeyValue(effectType, effect.Details)
	}

	// Handle different sponsorship effect types and create appropriate state changes
	//exhaustive:ignore
	switch effectType {
	// Created cases: when sponsorship relationships are established
	case EffectAccountSponsorshipCreated, EffectClaimableBalanceSponsorshipCreated,
		EffectDataSponsorshipCreated, EffectSignerSponsorshipCreated, EffectTrustlineSponsorshipCreated:
		sponsor, err := safeStringFromDetails(effect.Details, "sponsor")
		if err != nil {
			return nil, fmt.Errorf("extracting sponsor from sponsorship created effect: %w", err)
		}

		switch effectType {
		case EffectAccountSponsorshipCreated, EffectTrustlineSponsorshipCreated:
			// Generate 2 state changes for all sponsorship types
			sponsorChanges = append(sponsorChanges,
				// State change for sponsoring account
				p.createSponsorChangeForSponsoringAccount(types.StateChangeReasonSponsor, baseBuilder.Clone(), sponsor, effect.Address, keyValue),
				// State change for sponsored account (effect.Address)
				p.createSponsorChangeForSponsoredAccount(types.StateChangeReasonSponsor, baseBuilder.Clone(), effect.Address, sponsor, keyValue),
			)
		// Except the account sponsorship and trustline sponsorship, we don't have a sponsored account for the other types of sponsorships
		default:
			sponsorChanges = append(sponsorChanges,
				p.createSponsorChangeForSponsoringAccount(types.StateChangeReasonSponsor, baseBuilder.Clone(), sponsor, "", keyValue),
			)
		}

	// Removed cases: when sponsorship relationships are terminated
	case EffectAccountSponsorshipRemoved, EffectClaimableBalanceSponsorshipRemoved,
		EffectDataSponsorshipRemoved, EffectSignerSponsorshipRemoved, EffectTrustlineSponsorshipRemoved:
		formerSponsor, err := safeStringFromDetails(effect.Details, "former_sponsor")
		if err != nil {
			return nil, fmt.Errorf("extracting former sponsor from sponsorship removed effect: %w", err)
		}

		switch effectType {
		case EffectAccountSponsorshipRemoved, EffectTrustlineSponsorshipRemoved:
			// Generate 2 state changes for all sponsorship types
			sponsorChanges = append(sponsorChanges,
				// State change for sponsoring account
				p.createSponsorChangeForSponsoringAccount(types.StateChangeReasonUnsponsor, baseBuilder.Clone(), formerSponsor, effect.Address, keyValue),
				// State change for sponsored account (effect.Address)
				p.createSponsorChangeForSponsoredAccount(types.StateChangeReasonUnsponsor, baseBuilder.Clone(), effect.Address, formerSponsor, keyValue),
			)
		// Except the account sponsorship and trustline sponsorship, we don't have a sponsored account for the other types of sponsorships
		default:
			sponsorChanges = append(sponsorChanges,
				p.createSponsorChangeForSponsoringAccount(types.StateChangeReasonUnsponsor, baseBuilder.Clone(), formerSponsor, "", keyValue),
			)
		}

	// Updated cases: when sponsorship relationships are transferred from one sponsor to another
	case EffectAccountSponsorshipUpdated, EffectClaimableBalanceSponsorshipUpdated,
		EffectDataSponsorshipUpdated, EffectSignerSponsorshipUpdated, EffectTrustlineSponsorshipUpdated:
		newSponsor, err := safeStringFromDetails(effect.Details, "new_sponsor")
		if err != nil {
			return nil, fmt.Errorf("extracting new sponsor from sponsorship updated effect: %w", err)
		}
		formerSponsor, err := safeStringFromDetails(effect.Details, "former_sponsor")
		if err != nil {
			return nil, fmt.Errorf("extracting former sponsor from sponsorship updated effect: %w", err)
		}

		switch effectType {
		case EffectAccountSponsorshipUpdated, EffectTrustlineSponsorshipUpdated:
			// Generate 4 state changes for all sponsorship types
			sponsorChanges = append(sponsorChanges,
				// State change for new sponsoring account
				p.createSponsorChangeForSponsoringAccount(types.StateChangeReasonSponsor, baseBuilder.Clone(), newSponsor, effect.Address, keyValue),
				// State change for former sponsoring account
				p.createSponsorChangeForSponsoringAccount(types.StateChangeReasonUnsponsor, baseBuilder.Clone(), formerSponsor, effect.Address, keyValue),
				// State change for sponsored account with new sponsor
				p.createSponsorChangeForSponsoredAccount(types.StateChangeReasonSponsor, baseBuilder.Clone(), effect.Address, newSponsor, keyValue),
				// State change for sponsored account with former sponsor
				p.createSponsorChangeForSponsoredAccount(types.StateChangeReasonUnsponsor, baseBuilder.Clone(), effect.Address, formerSponsor, keyValue),
			)
		// Except the account sponsorship and trustline sponsorship, we don't have a sponsored account for the other types of sponsorships
		default:
			sponsorChanges = append(sponsorChanges,
				p.createSponsorChangeForSponsoringAccount(types.StateChangeReasonSponsor, baseBuilder.Clone(), newSponsor, "", keyValue),
				p.createSponsorChangeForSponsoringAccount(types.StateChangeReasonUnsponsor, baseBuilder.Clone(), formerSponsor, "", keyValue),
			)
		}
	}

	return sponsorChanges, nil
}

// createSponsorChangeForSponsoringAccount creates a state change for the sponsoring account in a sponsorship relationship.
// This tracks when an account starts, stops, or changes its sponsorship of another account's or entity's reserves.
// For account sponsorships, pass nil keyValue. For non-account sponsorships (trustline, data, claimable balance, signer),
// pass entity-specific details in keyValue.
func (p *EffectsProcessor) createSponsorChangeForSponsoringAccount(reason types.StateChangeReason, builder *StateChangeBuilder, accountID string, sponsoredAccountID string, keyValue map[string]any) types.StateChange {
	builder = builder.
		WithReason(reason).
		WithAccount(accountID)
	if sponsoredAccountID != "" {
		builder = builder.WithSponsoredAccountID(sponsoredAccountID)
	}
	if len(keyValue) > 0 {
		builder = builder.WithKeyValue(keyValue)
	}
	return builder.Build()
}

// createSponsorChangeForSponsoredAccount creates a state change for the sponsored account in a sponsorship relationship.
// This tracks when an account's account or entity reserves start, stop, or change sponsorship.
// For account sponsorships, pass nil keyValue. For non-account sponsorships (trustline, data, claimable balance, signer),
// pass entity-specific details in keyValue.
func (p *EffectsProcessor) createSponsorChangeForSponsoredAccount(reason types.StateChangeReason, builder *StateChangeBuilder, accountID string, sponsor string, keyValue map[string]any) types.StateChange {
	builder = builder.
		WithReason(reason).
		WithAccount(accountID).
		WithSponsor(sponsor)
	if len(keyValue) > 0 {
		builder = builder.WithKeyValue(keyValue)
	}
	return builder.Build()
}

// extractSponsorshipKeyValue extracts entity-specific details from sponsorship effect details.
// For different sponsorship types, it extracts: balance_id (claimable balance), data_name (data),
// asset/liquidity_pool_id (trustline), or signer (signer sponsorship).
func (p *EffectsProcessor) extractSponsorshipKeyValue(effectType EffectType, details map[string]interface{}) map[string]any {
	keyValue := make(map[string]any)

	//exhaustive:ignore
	switch effectType {
	case EffectTrustlineSponsorshipCreated, EffectTrustlineSponsorshipRemoved, EffectTrustlineSponsorshipUpdated:
		// Check if it's a liquidity pool trustline
		if assetType, ok := details["asset_type"]; ok && assetType == "liquidity_pool" {
			if liquidityPoolID, ok := details["liquidity_pool_id"]; ok {
				keyValue["liquidity_pool_id"] = liquidityPoolID
			}
		} else if asset, ok := details["asset"]; ok {
			keyValue["asset"] = asset
		}

	case EffectDataSponsorshipCreated, EffectDataSponsorshipRemoved, EffectDataSponsorshipUpdated:
		if dataName, ok := details["data_name"]; ok {
			keyValue["data_name"] = dataName
		}

	case EffectClaimableBalanceSponsorshipCreated, EffectClaimableBalanceSponsorshipRemoved, EffectClaimableBalanceSponsorshipUpdated:
		if balanceID, ok := details["balance_id"]; ok {
			keyValue["balance_id"] = balanceID
		}

	case EffectSignerSponsorshipCreated, EffectSignerSponsorshipRemoved, EffectSignerSponsorshipUpdated:
		if signer, ok := details["signer"]; ok {
			keyValue["signer"] = signer
		}
	}

	return keyValue
}

func (p *EffectsProcessor) parseTrustline(baseBuilder *StateChangeBuilder, effect *EffectOutput, effectType EffectType, changes []ingest.Change) (types.StateChange, error) {
	var assetCode, assetIssuer string
	assetType, err := safeStringFromDetails(effect.Details, "asset_type")
	if err != nil {
		return types.StateChange{}, fmt.Errorf("extracting asset type from effect details: %w", err)
	}
	if assetType == "liquidity_pool_shares" {
		var poolID string
		poolID, err = safeStringFromDetails(effect.Details, "liquidity_pool_id")
		if err != nil {
			return types.StateChange{}, fmt.Errorf("extracting liquidity pool ID from effect details: %w", err)
		}

		baseBuilder = baseBuilder.WithKeyValue(map[string]any{
			"liquidity_pool_id": poolID,
		}).WithTrustlineAsset(poolID) // poolID is already in the format poolAsset1:poolAsset2
	} else {
		assetCode, err = safeStringFromDetails(effect.Details, "asset_code")
		if err != nil {
			return types.StateChange{}, fmt.Errorf("extracting asset code from effect details: %w", err)
		}
		assetIssuer, err = safeStringFromDetails(effect.Details, "asset_issuer")
		if err != nil {
			return types.StateChange{}, fmt.Errorf("extracting asset issuer from effect details: %w", err)
		}
		assetContractID, err := getContractIDFromAssetDetails(p.networkPassphrase, assetType, assetCode, assetIssuer)
		if err != nil {
			return types.StateChange{}, fmt.Errorf("parsing asset: %w", err)
		}
		baseBuilder = baseBuilder.WithToken(assetContractID).WithTrustlineAsset(fmt.Sprintf("%s:%s", assetCode, assetIssuer))
	}

	var stateChange types.StateChange

	//exhaustive:ignore
	switch effectType {
	case EffectTrustlineCreated:
		// Create the trustline state change
		stateChange = baseBuilder.WithReason(types.StateChangeReasonAdd).WithTrustlineLimit(
			map[string]any{
				"limit": map[string]any{
					"new": effect.Details["limit"],
				},
			},
		).Build()

	case EffectTrustlineRemoved:
		stateChange = baseBuilder.WithReason(types.StateChangeReasonRemove).WithTrustlineAsset(fmt.Sprintf("%s:%s", assetCode, assetIssuer)).Build()

	case EffectTrustlineUpdated:
		prevLedgerEntryState := p.getPrevLedgerEntryState(effect, xdr.LedgerEntryTypeTrustline, changes)
		prevTrustline := prevLedgerEntryState.Data.MustTrustLine()
		stateChange = baseBuilder.WithReason(types.StateChangeReasonUpdate).WithTrustlineLimit(
			map[string]any{
				"limit": map[string]any{
					"old": strconv.FormatInt(int64(prevTrustline.Limit), 10),
					"new": effect.Details["limit"],
				},
			},
		).Build()
	}

	return stateChange, nil
}

// generateBalanceAuthorizationForNewTrustline generates balance authorization state changes
// for newly created trustlines by reading the trustline flags directly from transaction changes
func (p *EffectsProcessor) generateBalanceAuthorizationForNewTrustline(baseBuilder *StateChangeBuilder, effect *EffectOutput, changes []ingest.Change) (types.StateChange, error) {
	// Skip native assets as they don't have authorization
	assetType, err := safeStringFromDetails(effect.Details, "asset_type")
	if err != nil {
		return types.StateChange{}, fmt.Errorf("extracting asset type from effect details: %w", err)
	}
	if assetType == "native" {
		return types.StateChange{}, nil
	}

	var defaultFlags []string
	if assetType == "liquidity_pool_shares" {
		poolID, err := safeStringFromDetails(effect.Details, "liquidity_pool_id")
		if err != nil {
			return types.StateChange{}, fmt.Errorf("extracting liquidity pool ID from effect details: %w", err)
		}
		baseBuilder = baseBuilder.WithKeyValue(map[string]any{
			"liquidity_pool_id": poolID,
		})
	} else {
		assetCode, assetIssuer, assetContractID, err := p.buildAssetContractIDFromTrustlineEffect(effect)
		if err != nil {
			return types.StateChange{}, fmt.Errorf("building asset contract ID from trustline effect: %w", err)
		}
		baseBuilder = baseBuilder.WithToken(assetContractID)

		// Extract trustline flags directly from the transaction changes
		trustlineFlags, err := p.getTrustlineFlagsFromChanges(effect.Address, assetCode, assetIssuer, changes)
		if err != nil {
			return types.StateChange{}, fmt.Errorf("getting trustline flags from changes: %w", err)
		}

		// Map XDR trustline flags to our internal flag representation
		defaultFlags = p.mapTrustlineFlagsToStrings(trustlineFlags)
	}

	// Generate state changes for each flag that should be set
	return baseBuilder.Clone().
		WithCategory(types.StateChangeCategoryBalanceAuthorization).
		WithReason(types.StateChangeReasonSet).
		WithFlags(defaultFlags).
		Build(), nil
}

func (p *EffectsProcessor) buildAssetContractIDFromTrustlineEffect(effect *EffectOutput) (string, string, string, error) {
	assetType, err := safeStringFromDetails(effect.Details, "asset_type")
	if err != nil {
		return "", "", "", fmt.Errorf("extracting asset type from effect details: %w", err)
	}
	assetCode, err := safeStringFromDetails(effect.Details, "asset_code")
	if err != nil {
		return "", "", "", fmt.Errorf("extracting asset code from effect details: %w", err)
	}
	assetIssuer, err := safeStringFromDetails(effect.Details, "asset_issuer")
	if err != nil {
		return "", "", "", fmt.Errorf("extracting asset issuer from effect details: %w", err)
	}
	assetContractID, err := getContractIDFromAssetDetails(p.networkPassphrase, assetType, assetCode, assetIssuer)
	if err != nil {
		return "", "", "", fmt.Errorf("getting asset contract ID: %w", err)
	}
	return assetCode, assetIssuer, assetContractID, nil
}

// getTrustlineFlagsFromChanges extracts the trustline flags from transaction changes
func (p *EffectsProcessor) getTrustlineFlagsFromChanges(trustorAddress, assetCode, assetIssuer string, changes []ingest.Change) (xdr.TrustLineFlags, error) {
	// Search through changes to find the trustline entry for this specific asset and trustor. Note that these changes
	// are from the specific operation so we will only find the entries for the specific operation and not the entire transaction.
	for _, change := range changes {
		if change.Type != xdr.LedgerEntryTypeTrustline {
			continue
		}

		// Prefer Post state if available (most recent), otherwise use Pre
		var trustlineEntry xdr.TrustLineEntry
		if change.Post != nil {
			trustlineEntry = change.Post.Data.MustTrustLine()
		} else if change.Pre != nil {
			trustlineEntry = change.Pre.Data.MustTrustLine()
		} else {
			continue
		}

		// Match the trustline by trustor address
		if trustlineEntry.AccountId.Address() != trustorAddress {
			continue
		}

		// Match the trustline by asset
		asset := trustlineEntry.Asset

		var entryAssetCode, entryAssetIssuer string
		//exhaustive:ignore
		switch asset.Type {
		case xdr.AssetTypeAssetTypeNative:
			continue
		case xdr.AssetTypeAssetTypeCreditAlphanum4:
			alphaNum4 := asset.MustAlphaNum4()
			assetCodeBytes := alphaNum4.AssetCode[:]
			entryAssetCode = string(assetCodeBytes)
			entryAssetIssuer = alphaNum4.Issuer.Address()
		case xdr.AssetTypeAssetTypeCreditAlphanum12:
			alphaNum12 := asset.MustAlphaNum12()
			assetCodeBytes := alphaNum12.AssetCode[:]
			entryAssetCode = string(assetCodeBytes)
			entryAssetIssuer = alphaNum12.Issuer.Address()
		}

		// Remove null bytes from asset code
		for i, c := range entryAssetCode {
			if c == 0 {
				entryAssetCode = entryAssetCode[:i]
				break
			}
		}

		if entryAssetCode == assetCode && entryAssetIssuer == assetIssuer {
			return xdr.TrustLineFlags(trustlineEntry.Flags), nil
		}
	}

	return 0, fmt.Errorf("trustline not found in changes for trustor: %s, asset: %s:%s", trustorAddress, assetCode, assetIssuer)
}

// mapTrustlineFlagsToStrings converts XDR trustline flags to our internal string representation
func (p *EffectsProcessor) mapTrustlineFlagsToStrings(flags xdr.TrustLineFlags) []string {
	var flagStrings []string

	if flags.IsAuthorized() {
		flagStrings = append(flagStrings, AuthorizedFlagName)
	}

	if flags.IsAuthorizedToMaintainLiabilitiesFlag() {
		flagStrings = append(flagStrings, AuthorizedToMaintainLiabilitiesFlagName)
	}

	if flags.IsClawbackEnabledFlag() {
		flagStrings = append(flagStrings, ClawbackEnabledFlagName)
	}

	return flagStrings
}

// parseKeyValue extracts specified key-value pairs from effect details.
// This is used to capture metadata like home domain values or data entry names and values.
func (p *EffectsProcessor) parseKeyValue(effect *EffectOutput, effectType EffectType, changes []ingest.Change, key string) map[string]any {
	prevLedgerEntryState := p.getPrevLedgerEntryState(effect, xdr.LedgerEntryTypeData, changes)
	keyValueMap := map[string]any{}
	if key == "name" {
		keyName := string(effect.Details[key].(xdr.String64))

		//exhaustive:ignore
		switch effectType {
		case EffectDataCreated:
			if value, ok := effect.Details["value"]; ok {
				keyValueMap[keyName] = map[string]any{
					"new": value,
				}
			}
		case EffectDataUpdated, EffectDataRemoved:
			innerMap := map[string]any{}
			if prevLedgerEntryState != nil {
				oldData := prevLedgerEntryState.Data.MustData().DataValue
				innerMap["old"] = base64.StdEncoding.EncodeToString(oldData)
			}
			if effectType == EffectDataUpdated {
				if value, ok := effect.Details["value"]; ok {
					innerMap["new"] = value
				}
			}
			keyValueMap[keyName] = innerMap
		}
	} else {
		if value, ok := effect.Details[key]; ok {
			keyValueMap[key] = value
		}
	}

	return keyValueMap
}

// parseFlags processes flag-related effects and creates separate state changes for set and cleared flags.
// Stellar flags can be either set (true) or cleared (false), and we track each change separately.
func (p *EffectsProcessor) parseFlags(flags []string, changeBuilder *StateChangeBuilder, effect *EffectOutput) []types.StateChange {
	var setFlags, clearFlags []string

	for _, flag := range flags {
		flagName := flag
		// We dont want to use the "_flag" suffix for the flag names
		if flag == "authorized_flag" {
			flagName = AuthorizedFlagName
		}
		if flag == "clawback_enabled_flag" {
			flagName = ClawbackEnabledFlagName
		}
		if flag == "auth_required_flag" {
			flagName = AuthorizedRequiredFlagName
		}
		if flag == "auth_revocable_flag" {
			flagName = AuthorizedRevocableFlagName
		}
		if flag == "auth_immutable_flag" {
			flagName = AuthorizedImmutableFlagName
		}
		if flag == "auth_clawback_enabled_flag" {
			flagName = AuthorizedClawbackEnabledFlagName
		}
		if value, ok := effect.Details[flag]; ok {
			if value == true {
				setFlags = append(setFlags, flagName)
			} else {
				clearFlags = append(clearFlags, flagName)
			}
		}
	}

	var changes []types.StateChange
	if len(setFlags) > 0 {
		changes = append(changes, changeBuilder.
			Clone().
			WithReason(types.StateChangeReasonSet).
			WithFlags(setFlags).
			Build())
	}
	if len(clearFlags) > 0 {
		changes = append(changes, changeBuilder.
			Clone().
			WithReason(types.StateChangeReasonClear).
			WithFlags(clearFlags).
			Build())
	}

	return changes
}

func (p *EffectsProcessor) parseSigners(changeBuilder *StateChangeBuilder, effect *EffectOutput, effectType EffectType, changes []ingest.Change) ([]types.StateChange, error) {
	signerPublicKey := effect.Details["public_key"].(string)
	weight, err := convertToInt32(effect.Details["weight"])
	if err != nil {
		return nil, fmt.Errorf("converting weight for signer effect: %w", err)
	}

	//exhaustive:ignore
	switch effectType {
	case EffectSignerCreated:
		changeBuilder = changeBuilder.WithSigner(
			signerPublicKey,
			map[string]any{
				"new": weight,
			},
		)
	case EffectSignerUpdated, EffectSignerRemoved:
		weights := map[string]any{}
		prevLedgerEntryState := p.getPrevLedgerEntryState(effect, xdr.LedgerEntryTypeAccount, changes)
		if prevLedgerEntryState != nil {
			prevAccount := prevLedgerEntryState.Data.MustAccount()
			oldSignerSummary := prevAccount.SignerSummary()
			weights["old"] = oldSignerSummary[signerPublicKey]
		} else {
			log.Debugf("no previous account state found for account: %s: opID: %d", effect.Address, effect.OperationID)
		}
		if effectType == EffectSignerUpdated {
			weights["new"] = weight
		}
		changeBuilder = changeBuilder.WithSigner(signerPublicKey, weights)
	}
	return []types.StateChange{changeBuilder.Build()}, nil
}

// parseThresholds processes threshold-related effects and creates state changes for each threshold type.
// It extracts both old and new threshold values from the ledger entry changes.
func (p *EffectsProcessor) parseThresholds(changeBuilder *StateChangeBuilder, effect *EffectOutput, changes []ingest.Change) []types.StateChange {
	// Find the account entry change to get old threshold values
	prevLedgerEntryState := p.getPrevLedgerEntryState(effect, xdr.LedgerEntryTypeAccount, changes)

	// Create a separate state change for each threshold that was modified
	var thresholdChanges []types.StateChange
	for threshold, reason := range thresholdToReasonMap {
		if value, ok := effect.Details[threshold]; ok {
			// Convert XDR threshold value to string for storage
			thresholdValue := strconv.FormatInt(int64(value.(xdr.Uint32)), 10)

			// Create threshold details with both old and new values
			thresholdDetails := map[string]any{
				"new": thresholdValue,
			}

			// Add old threshold value if available
			if prevLedgerEntryState != nil {
				var oldValue string
				prevAccount := prevLedgerEntryState.Data.MustAccount()
				switch threshold {
				case "low_threshold":
					oldValue = strconv.FormatInt(int64(prevAccount.Thresholds[lowThresholdIndex]), 10)
				case "med_threshold":
					oldValue = strconv.FormatInt(int64(prevAccount.Thresholds[medThresholdIndex]), 10)
				case "high_threshold":
					oldValue = strconv.FormatInt(int64(prevAccount.Thresholds[highThresholdIndex]), 10)
				}
				thresholdDetails["old"] = oldValue
			} else {
				log.Debugf("no previous account state found for account: %s: opID: %d", effect.Address, effect.OperationID)
			}

			thresholdChanges = append(thresholdChanges, changeBuilder.
				Clone().
				WithReason(reason).
				WithThresholds(thresholdDetails).
				Build())
		}
	}
	return thresholdChanges
}

// getPrevLedgerEntryState gets the previous ledger entry state for the specified ledger entry type.
func (p *EffectsProcessor) getPrevLedgerEntryState(effect *EffectOutput, ledgerEntryType xdr.LedgerEntryType, changes []ingest.Change) *xdr.LedgerEntry {
	for _, change := range changes {
		if change.Type != ledgerEntryType {
			continue
		}
		if change.Pre != nil {
			beforeEntry := change.Pre
			if beforeEntry != nil {
				if ledgerEntryType == xdr.LedgerEntryTypeAccount {
					beforeAccount := beforeEntry.Data.MustAccount()
					if beforeAccount.AccountId.Address() == effect.Address {
						return beforeEntry
					}
				}
				return beforeEntry
			}
		}
	}
	return nil
}
