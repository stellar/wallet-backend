package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/stellar/go/xdr"
	"github.com/stellar/wallet-backend/internal/data"
	"github.com/stellar/wallet-backend/internal/entities"
	"github.com/stellar/wallet-backend/internal/indexer/types"
	graphql1 "github.com/stellar/wallet-backend/internal/serve/graphql/generated"
	"github.com/stellar/wallet-backend/internal/services"
	"github.com/stellar/wallet-backend/internal/signing"
	"github.com/stellar/wallet-backend/internal/signing/store"
	transactionservices "github.com/stellar/wallet-backend/internal/transactions/services"
	transactionsUtils "github.com/stellar/wallet-backend/internal/transactions/utils"
	"github.com/stellar/wallet-backend/pkg/sorobanauth"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// RegisterAccount is the resolver for the registerAccount field.
func (r *mutationResolver) RegisterAccount(ctx context.Context, input graphql1.RegisterAccountInput) (*graphql1.RegisterAccountPayload, error) {
	err := r.accountService.RegisterAccount(ctx, input.Address)
	if err != nil {
		if errors.Is(err, data.ErrAccountAlreadyExists) {
			return nil, &gqlerror.Error{
				Message: "Account is already registered",
				Extensions: map[string]interface{}{
					"code": "ACCOUNT_ALREADY_EXISTS",
				},
			}
		}
		if errors.Is(err, services.ErrInvalidAddress) {
			return nil, &gqlerror.Error{
				Message: "Invalid address: must be a valid Stellar public key or contract address",
				Extensions: map[string]interface{}{
					"code": "INVALID_ADDRESS",
				},
			}
		}
		return nil, &gqlerror.Error{
			Message: fmt.Sprintf("Failed to register account: %s", err.Error()),
			Extensions: map[string]interface{}{
				"code": "ACCOUNT_REGISTRATION_FAILED",
			},
		}
	}

	// Return the account data directly since we know the address
	account := &types.Account{
		StellarAddress: input.Address,
		CreatedAt:      time.Now(),
	}

	return &graphql1.RegisterAccountPayload{
		Success: true,
		Account: account,
	}, nil
}

// DeregisterAccount is the resolver for the deregisterAccount field.
func (r *mutationResolver) DeregisterAccount(ctx context.Context, input graphql1.DeregisterAccountInput) (*graphql1.DeregisterAccountPayload, error) {
	err := r.accountService.DeregisterAccount(ctx, input.Address)
	if err != nil {
		if errors.Is(err, data.ErrAccountNotFound) {
			return nil, &gqlerror.Error{
				Message: "Account not found",
				Extensions: map[string]interface{}{
					"code": "ACCOUNT_NOT_FOUND",
				},
			}
		}
		return nil, &gqlerror.Error{
			Message: fmt.Sprintf("Failed to deregister account: %s", err.Error()),
			Extensions: map[string]interface{}{
				"code": "ACCOUNT_DEREGISTRATION_FAILED",
			},
		}
	}

	return &graphql1.DeregisterAccountPayload{
		Success: true,
		Message: &[]string{"Account deregistered successfully"}[0],
	}, nil
}

// BuildTransaction is the resolver for the buildTransaction field.
func (r *mutationResolver) BuildTransaction(ctx context.Context, input graphql1.BuildTransactionInput) (*graphql1.BuildTransactionPayload, error) {
	transaction := input.Transaction

	ops, err := transactionsUtils.BuildOperations(transaction.Operations)
	if err != nil {
		return nil, &gqlerror.Error{
			Message: fmt.Sprintf("Invalid operations: %s", err.Error()),
			Extensions: map[string]interface{}{
				"code": "INVALID_OPERATIONS",
			},
		}
	}

	// Convert simulation result if provided
	var simulationResult entities.RPCSimulateTransactionResult
	if transaction.SimulationResult != nil {
		simulationResult = entities.RPCSimulateTransactionResult{
			Events: transaction.SimulationResult.Events,
		}

		if transaction.SimulationResult.MinResourceFee != nil {
			simulationResult.MinResourceFee = *transaction.SimulationResult.MinResourceFee
		}
		if transaction.SimulationResult.Error != nil {
			simulationResult.Error = *transaction.SimulationResult.Error
		}
		if transaction.SimulationResult.LatestLedger != nil {
			simulationResult.LatestLedger = int64(*transaction.SimulationResult.LatestLedger)
		}

		// Handle TransactionData if provided
		if transaction.SimulationResult.TransactionData != nil {
			var txData xdr.SorobanTransactionData
			if txDataErr := xdr.SafeUnmarshalBase64(*transaction.SimulationResult.TransactionData, &txData); txDataErr != nil {
				return nil, &gqlerror.Error{
					Message: fmt.Sprintf("Invalid TransactionData: %s", txDataErr.Error()),
					Extensions: map[string]interface{}{
						"code": "INVALID_TRANSACTION_DATA",
					},
				}
			}
			simulationResult.TransactionData = txData
		}
	}

	tx, err := r.transactionService.BuildAndSignTransactionWithChannelAccount(ctx, ops, int64(transaction.Timeout), simulationResult)
	if err != nil {
		switch {
		case errors.Is(err, transactionservices.ErrInvalidTimeout):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]interface{}{
					"code": "INVALID_TIMEOUT",
				},
			}
		case errors.Is(err, transactionservices.ErrInvalidOperationChannelAccount):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]interface{}{
					"code": "INVALID_OPERATION_CHANNEL_ACCOUNT",
				},
			}
		case errors.Is(err, transactionservices.ErrInvalidOperationMissingSource):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]interface{}{
					"code": "INVALID_OPERATION_MISSING_SOURCE",
				},
			}
		case errors.Is(err, transactionservices.ErrInvalidSorobanOperationCount):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]interface{}{
					"code": "INVALID_SOROBAN_OPERATION_COUNT",
				},
			}
		case errors.Is(err, transactionservices.ErrInvalidSorobanSimulationEmpty):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]interface{}{
					"code": "INVALID_SOROBAN_SIMULATION_EMPTY",
				},
			}
		case errors.Is(err, transactionservices.ErrInvalidSorobanSimulationFailed):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]interface{}{
					"code": "INVALID_SOROBAN_SIMULATION_FAILED",
				},
			}
		case errors.Is(err, transactionservices.ErrInvalidSorobanOperationType):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]interface{}{
					"code": "INVALID_SOROBAN_OPERATION_TYPE",
				},
			}
		case errors.Is(err, signing.ErrUnavailableChannelAccounts):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]interface{}{
					"code": "UNAVAILABLE_CHANNEL_ACCOUNTS",
				},
			}
		case errors.Is(err, sorobanauth.ErrForbiddenSigner):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]interface{}{
					"code": "FORBIDDEN_SIGNER",
				},
			}
		case errors.Is(err, store.ErrNoIdleChannelAccountAvailable):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]interface{}{
					"code": "NO_IDLE_CHANNEL_ACCOUNT",
				},
			}
		default:
			return nil, &gqlerror.Error{
				Message: fmt.Sprintf("Failed to build transaction: %s", err.Error()),
				Extensions: map[string]interface{}{
					"code": "TRANSACTION_BUILD_FAILED",
				},
			}
		}
	}

	// Convert transaction to XDR string
	txXdrStr, err := tx.Base64()
	if err != nil {
		return nil, &gqlerror.Error{
			Message: fmt.Sprintf("Failed to encode transaction to XDR: %s", err.Error()),
			Extensions: map[string]interface{}{
				"code": "XDR_ENCODING_FAILED",
			},
		}
	}

	return &graphql1.BuildTransactionPayload{
		Success:        true,
		TransactionXdr: txXdrStr,
	}, nil
}

// Mutation returns graphql1.MutationResolver implementation.
func (r *Resolver) Mutation() graphql1.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
