package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"time"

	"github.com/stellar/go/support/log"
	"github.com/stellar/go/txnbuild"
	"github.com/stellar/go/xdr"
	"github.com/vektah/gqlparser/v2/gqlerror"

	"github.com/stellar/wallet-backend/internal/data"
	"github.com/stellar/wallet-backend/internal/entities"
	"github.com/stellar/wallet-backend/internal/indexer/types"
	graphql1 "github.com/stellar/wallet-backend/internal/serve/graphql/generated"
	"github.com/stellar/wallet-backend/internal/services"
	"github.com/stellar/wallet-backend/internal/signing"
	"github.com/stellar/wallet-backend/internal/signing/store"
	transactionservices "github.com/stellar/wallet-backend/internal/transactions/services"
	transactionsUtils "github.com/stellar/wallet-backend/internal/transactions/utils"
	"github.com/stellar/wallet-backend/pkg/sorobanauth"
)

// RegisterAccount is the resolver for the registerAccount field.
func (r *mutationResolver) RegisterAccount(ctx context.Context, input graphql1.RegisterAccountInput) (*graphql1.RegisterAccountPayload, error) {
	err := r.accountService.RegisterAccount(ctx, input.Address)
	if err != nil {
		if errors.Is(err, data.ErrAccountAlreadyExists) {
			return nil, &gqlerror.Error{
				Message: ErrMsgAccountAlreadyExists,
				Extensions: map[string]interface{}{
					"code": "ACCOUNT_ALREADY_EXISTS",
				},
			}
		}
		if errors.Is(err, services.ErrInvalidAddress) {
			return nil, &gqlerror.Error{
				Message: ErrMsgInvalidAddress,
				Extensions: map[string]interface{}{
					"code": "INVALID_ADDRESS",
				},
			}
		}
		return nil, &gqlerror.Error{
			Message: fmt.Sprintf(ErrMsgAccountRegistrationFailed, err.Error()),
			Extensions: map[string]interface{}{
				"code": "ACCOUNT_REGISTRATION_FAILED",
			},
		}
	}

	// Return the account data directly since we know the address
	account := &types.Account{
		StellarAddress: input.Address,
		CreatedAt:      time.Now(),
	}

	return &graphql1.RegisterAccountPayload{
		Success: true,
		Account: account,
	}, nil
}

// DeregisterAccount is the resolver for the deregisterAccount field.
func (r *mutationResolver) DeregisterAccount(ctx context.Context, input graphql1.DeregisterAccountInput) (*graphql1.DeregisterAccountPayload, error) {
	err := r.accountService.DeregisterAccount(ctx, input.Address)
	if err != nil {
		if errors.Is(err, data.ErrAccountNotFound) {
			return nil, &gqlerror.Error{
				Message: ErrMsgAccountNotFound,
				Extensions: map[string]interface{}{
					"code": "ACCOUNT_NOT_FOUND",
				},
			}
		}
		return nil, &gqlerror.Error{
			Message: fmt.Sprintf(ErrMsgAccountDeregistrationFailed, err.Error()),
			Extensions: map[string]interface{}{
				"code": "ACCOUNT_DEREGISTRATION_FAILED",
			},
		}
	}

	return &graphql1.DeregisterAccountPayload{
		Success: true,
		Message: &[]string{ErrMsgAccountDeregisteredSuccess}[0],
	}, nil
}

// BuildTransaction is the resolver for the buildTransaction field.
func (r *mutationResolver) BuildTransaction(ctx context.Context, input graphql1.BuildTransactionInput) (*graphql1.BuildTransactionPayload, error) {
	transaction := input.Transaction

	ops, err := transactionsUtils.BuildOperations(transaction.Operations)
	if err != nil {
		return nil, &gqlerror.Error{
			Message: fmt.Sprintf(ErrMsgInvalidOperations, err.Error()),
			Extensions: map[string]interface{}{
				"code": "INVALID_OPERATIONS",
			},
		}
	}

	// Convert memo if provided
	var memo txnbuild.Memo
	if transaction.Memo != nil {
		convertedMemo, memoErr := r.convertMemo(transaction.Memo)
		if memoErr != nil {
			return nil, memoErr
		}
		memo = convertedMemo
	}

	// Convert preconditions if provided
	var preconditions txnbuild.Preconditions
	if transaction.Preconditions != nil {
		convertedPreconditions, preconditionsErr := r.convertPreconditions(transaction.Preconditions)
		if preconditionsErr != nil {
			return nil, preconditionsErr
		}
		preconditions = convertedPreconditions
	}

	// Convert simulation result if provided
	var simulationResult entities.RPCSimulateTransactionResult
	if transaction.SimulationResult != nil {
		convertedSimulationResult, simulationResultErr := r.convertSimulationResult(transaction.SimulationResult)
		if simulationResultErr != nil {
			return nil, simulationResultErr
		}
		simulationResult = convertedSimulationResult
	}

	tx, err := r.transactionService.BuildAndSignTransactionWithChannelAccount(ctx, ops, int64(transaction.Timeout), memo, preconditions, simulationResult)
	if err != nil {
		switch {
		case errors.Is(err, transactionservices.ErrInvalidTimeout):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]interface{}{
					"code": "INVALID_TIMEOUT",
				},
			}
		case errors.Is(err, transactionservices.ErrInvalidOperationChannelAccount):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]interface{}{
					"code": "INVALID_OPERATION_CHANNEL_ACCOUNT",
				},
			}
		case errors.Is(err, transactionservices.ErrInvalidOperationMissingSource):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]interface{}{
					"code": "INVALID_OPERATION_MISSING_SOURCE",
				},
			}
		case errors.Is(err, transactionservices.ErrInvalidSorobanOperationCount):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]interface{}{
					"code": "INVALID_SOROBAN_OPERATION_COUNT",
				},
			}
		case errors.Is(err, transactionservices.ErrInvalidSorobanSimulationEmpty):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]interface{}{
					"code": "INVALID_SOROBAN_SIMULATION_EMPTY",
				},
			}
		case errors.Is(err, transactionservices.ErrInvalidSorobanSimulationFailed):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]interface{}{
					"code": "INVALID_SOROBAN_SIMULATION_FAILED",
				},
			}
		case errors.Is(err, transactionservices.ErrInvalidSorobanOperationType):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]interface{}{
					"code": "INVALID_SOROBAN_OPERATION_TYPE",
				},
			}
		case errors.Is(err, signing.ErrUnavailableChannelAccounts), errors.Is(err, store.ErrNoIdleChannelAccountAvailable):
			return nil, &gqlerror.Error{
				Message: ErrMsgChannelAccountUnavailable,
				Extensions: map[string]interface{}{
					"code": "CHANNEL_ACCOUNT_UNAVAILABLE",
				},
			}
		case errors.Is(err, sorobanauth.ErrForbiddenSigner):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]interface{}{
					"code": "FORBIDDEN_SIGNER",
				},
			}
		default:
			log.Errorf("Failed to build transaction: %v", err)
			return nil, &gqlerror.Error{
				Message: ErrMsgTransactionBuildFailed,
				Extensions: map[string]interface{}{
					"code": "TRANSACTION_BUILD_FAILED",
				},
			}
		}
	}

	// Convert transaction to XDR string
	txXdrStr, _ := tx.Base64()

	return &graphql1.BuildTransactionPayload{
		Success:        true,
		TransactionXdr: txXdrStr,
	}, nil
}

// CreateFeeBumpTransaction is the resolver for the createFeeBumpTransaction field.
func (r *mutationResolver) CreateFeeBumpTransaction(ctx context.Context, input graphql1.CreateFeeBumpTransactionInput) (*graphql1.CreateFeeBumpTransactionPayload, error) {
	genericTx, err := txnbuild.TransactionFromXDR(input.TransactionXdr)
	if err != nil {
		return nil, &gqlerror.Error{
			Message: ErrMsgCouldNotParseTransactionEnvelope,
			Extensions: map[string]any{
				"code": "INVALID_TRANSACTION_XDR",
			},
		}
	}

	_, ok := genericTx.FeeBump()
	if ok {
		return nil, &gqlerror.Error{
			Message: ErrMsgCannotWrapFeeBumpTransaction,
			Extensions: map[string]any{
				"code": "FEE_BUMP_TX_NOT_ALLOWED",
			},
		}
	}

	tx, ok := genericTx.Transaction()
	if !ok {
		return nil, &gqlerror.Error{
			Message: ErrMsgInvalidTransaction,
			Extensions: map[string]any{
				"code": "INVALID_TRANSACTION",
			},
		}
	}

	feeBumpTxe, networkPassphrase, err := r.feeBumpService.WrapTransaction(ctx, tx)
	if err != nil {
		switch {
		case errors.Is(err, services.ErrFeeExceedsMaximumBaseFee):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]any{
					"code":           "FEE_EXCEEDS_MAXIMUM",
					"maximumBaseFee": r.feeBumpService.GetMaximumBaseFee(),
				},
			}
		case errors.Is(err, services.ErrNoSignaturesProvided):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]any{
					"code": "NO_SIGNATURES_PROVIDED",
				},
			}
		case errors.Is(err, services.ErrAccountNotEligibleForBeingSponsored):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]any{
					"code": "ACCOUNT_NOT_ELIGIBLE_FOR_BEING_SPONSORED",
				},
			}
		default:
			return nil, &gqlerror.Error{
				Message: fmt.Sprintf(ErrMsgFeeBumpCreationFailed, err.Error()),
				Extensions: map[string]any{
					"code": "FEE_BUMP_CREATION_FAILED",
				},
			}
		}
	}

	return &graphql1.CreateFeeBumpTransactionPayload{
		Success:           true,
		Transaction:       feeBumpTxe,
		NetworkPassphrase: networkPassphrase,
	}, nil
}

// convertSimulationResult converts GraphQL SimulationResultInput to entities.RPCSimulateTransactionResult
func (r *mutationResolver) convertSimulationResult(simulationResultInput *graphql1.SimulationResultInput) (entities.RPCSimulateTransactionResult, *gqlerror.Error) {
	simulationResult := entities.RPCSimulateTransactionResult{
		Events: simulationResultInput.Events,
	}

	if simulationResultInput.MinResourceFee != nil {
		simulationResult.MinResourceFee = *simulationResultInput.MinResourceFee
	}
	if simulationResultInput.Error != nil {
		simulationResult.Error = *simulationResultInput.Error
	}
	if simulationResultInput.LatestLedger != nil {
		simulationResult.LatestLedger = int64(*simulationResultInput.LatestLedger)
	}

	// Handle TransactionData if provided
	if simulationResultInput.TransactionData != nil {
		var txData xdr.SorobanTransactionData
		if txDataErr := xdr.SafeUnmarshalBase64(*simulationResultInput.TransactionData, &txData); txDataErr != nil {
			return entities.RPCSimulateTransactionResult{}, &gqlerror.Error{
				Message: fmt.Sprintf("Invalid TransactionData: %s", txDataErr.Error()),
				Extensions: map[string]interface{}{
					"code": "INVALID_TRANSACTION_DATA",
				},
			}
		}
		simulationResult.TransactionData = txData
	}

	return simulationResult, nil
}

// convertMemo converts GraphQL MemoInput to txnbuild.Memo with validation
func (r *mutationResolver) convertMemo(memoInput *graphql1.MemoInput) (txnbuild.Memo, *gqlerror.Error) {
	switch memoInput.Type {
	case graphql1.MemoTypeMemoNone:
		return nil, nil
	case graphql1.MemoTypeMemoText:
		if memoInput.Text == nil {
			return nil, &gqlerror.Error{
				Message: "text field is required for MEMO_TEXT",
				Extensions: map[string]interface{}{
					"code": "INVALID_MEMO",
				},
			}
		}
		if len(*memoInput.Text) > 28 {
			return nil, &gqlerror.Error{
				Message: "memo text cannot exceed 28 characters",
				Extensions: map[string]interface{}{
					"code": "INVALID_MEMO",
				},
			}
		}
		return txnbuild.MemoText(*memoInput.Text), nil
	case graphql1.MemoTypeMemoID:
		if memoInput.ID == nil {
			return nil, &gqlerror.Error{
				Message: "id field is required for MEMO_ID",
				Extensions: map[string]interface{}{
					"code": "INVALID_MEMO",
				},
			}
		}
		id, err := strconv.ParseUint(*memoInput.ID, 10, 64)
		if err != nil {
			return nil, &gqlerror.Error{
				Message: fmt.Sprintf("invalid memo id: %s", err.Error()),
				Extensions: map[string]interface{}{
					"code": "INVALID_MEMO",
				},
			}
		}
		return txnbuild.MemoID(id), nil
	case graphql1.MemoTypeMemoHash:
		if memoInput.Hash == nil {
			return nil, &gqlerror.Error{
				Message: "hash field is required for MEMO_HASH",
				Extensions: map[string]interface{}{
					"code": "INVALID_MEMO",
				},
			}
		}
		// Convert hex string to [32]byte
		var hashBytes xdr.Hash
		if err := xdr.SafeUnmarshalBase64(*memoInput.Hash, &hashBytes); err != nil {
			return nil, &gqlerror.Error{
				Message: fmt.Sprintf("invalid memo hash: %s", err.Error()),
				Extensions: map[string]interface{}{
					"code": "INVALID_MEMO",
				},
			}
		}
		return txnbuild.MemoHash(hashBytes), nil
	case graphql1.MemoTypeMemoReturn:
		if memoInput.RetHash == nil {
			return nil, &gqlerror.Error{
				Message: "retHash field is required for MEMO_RETURN",
				Extensions: map[string]interface{}{
					"code": "INVALID_MEMO",
				},
			}
		}
		// Convert hex string to [32]byte
		var retHashBytes xdr.Hash
		if err := xdr.SafeUnmarshalBase64(*memoInput.RetHash, &retHashBytes); err != nil {
			return nil, &gqlerror.Error{
				Message: fmt.Sprintf("invalid memo retHash: %s", err.Error()),
				Extensions: map[string]interface{}{
					"code": "INVALID_MEMO",
				},
			}
		}
		return txnbuild.MemoReturn(retHashBytes), nil
	default:
		return nil, &gqlerror.Error{
			Message: fmt.Sprintf("unsupported memo type: %s", memoInput.Type),
			Extensions: map[string]interface{}{
				"code": "INVALID_MEMO",
			},
		}
	}
}

// convertPreconditions converts GraphQL PreconditionsInput to txnbuild.Preconditions with validation
func (r *mutationResolver) convertPreconditions(preconditionsInput *graphql1.PreconditionsInput) (txnbuild.Preconditions, *gqlerror.Error) {
	var preconditions txnbuild.Preconditions

	// Convert TimeBounds
	if preconditionsInput.TimeBounds != nil {
		var minTime, maxTime int64

		if preconditionsInput.TimeBounds.MinTime != nil {
			var err error
			minTime, err = strconv.ParseInt(*preconditionsInput.TimeBounds.MinTime, 10, 64)
			if err != nil {
				return preconditions, &gqlerror.Error{
					Message: fmt.Sprintf("invalid minTime: %s", err.Error()),
					Extensions: map[string]interface{}{
						"code": "INVALID_PRECONDITIONS",
					},
				}
			}
		}

		if preconditionsInput.TimeBounds.MaxTime != nil {
			var err error
			maxTime, err = strconv.ParseInt(*preconditionsInput.TimeBounds.MaxTime, 10, 64)
			if err != nil {
				return preconditions, &gqlerror.Error{
					Message: fmt.Sprintf("invalid maxTime: %s", err.Error()),
					Extensions: map[string]interface{}{
						"code": "INVALID_PRECONDITIONS",
					},
				}
			}
		}

		preconditions.TimeBounds = txnbuild.NewTimebounds(minTime, maxTime)
	}

	// Convert LedgerBounds
	if preconditionsInput.LedgerBounds != nil {
		preconditions.LedgerBounds = &txnbuild.LedgerBounds{
			MinLedger: uint32(*preconditionsInput.LedgerBounds.MinLedger),
			MaxLedger: uint32(*preconditionsInput.LedgerBounds.MaxLedger),
		}
	}

	// Convert MinSequenceNumber
	if preconditionsInput.MinSeqNum != nil {
		minSeqNum, err := strconv.ParseInt(*preconditionsInput.MinSeqNum, 10, 64)
		if err != nil {
			return preconditions, &gqlerror.Error{
				Message: fmt.Sprintf("invalid minSeqNum: %s", err.Error()),
				Extensions: map[string]interface{}{
					"code": "INVALID_PRECONDITIONS",
				},
			}
		}
		preconditions.MinSequenceNumber = &minSeqNum
	}

	// Convert MinSequenceNumberAge
	if preconditionsInput.MinSeqAge != nil {
		minSeqAge, err := strconv.ParseUint(*preconditionsInput.MinSeqAge, 10, 64)
		if err != nil {
			return preconditions, &gqlerror.Error{
				Message: fmt.Sprintf("invalid minSeqAge: %s", err.Error()),
				Extensions: map[string]interface{}{
					"code": "INVALID_PRECONDITIONS",
				},
			}
		}
		preconditions.MinSequenceNumberAge = minSeqAge
	}

	// Convert MinSequenceNumberLedgerGap
	if preconditionsInput.MinSeqLedgerGap != nil {
		preconditions.MinSequenceNumberLedgerGap = uint32(*preconditionsInput.MinSeqLedgerGap)
	}

	// Convert ExtraSigners
	if len(preconditionsInput.ExtraSigners) > 0 {
		for _, signerStr := range preconditionsInput.ExtraSigners {
			// Validate signer address format
			if err := validateStellarSignerKey(signerStr); err != nil {
				return preconditions, &gqlerror.Error{
					Message: fmt.Sprintf("invalid extra signer: %s", err.Error()),
					Extensions: map[string]interface{}{
						"code": "INVALID_PRECONDITIONS",
					},
				}
			}
			preconditions.ExtraSigners = append(preconditions.ExtraSigners, signerStr)
		}
	}

	return preconditions, nil
}

// validateStellarSignerKey validates a stellar signer key format
func validateStellarSignerKey(signerKey string) error {
	if signerKey == "" {
		return fmt.Errorf("signer key is undefined")
	}
	var xdrKey xdr.SignerKey
	if err := xdrKey.SetAddress(signerKey); err != nil {
		return fmt.Errorf("%s is not a valid stellar signer key", signerKey)
	}
	return nil
}

// Mutation returns graphql1.MutationResolver implementation.
func (r *Resolver) Mutation() graphql1.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
