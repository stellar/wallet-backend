package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/stellar/go-stellar-sdk/txnbuild"
	"github.com/vektah/gqlparser/v2/gqlerror"

	"github.com/stellar/wallet-backend/internal/data"
	"github.com/stellar/wallet-backend/internal/entities"
	"github.com/stellar/wallet-backend/internal/indexer/types"
	graphql1 "github.com/stellar/wallet-backend/internal/serve/graphql/generated"
	"github.com/stellar/wallet-backend/internal/services"
	"github.com/stellar/wallet-backend/internal/signing"
	"github.com/stellar/wallet-backend/internal/signing/store"
	"github.com/stellar/wallet-backend/pkg/sorobanauth"
)

// RegisterAccount is the resolver for the registerAccount field.
func (r *mutationResolver) RegisterAccount(ctx context.Context, input graphql1.RegisterAccountInput) (*graphql1.RegisterAccountPayload, error) {
	err := r.accountService.RegisterAccount(ctx, input.Address)
	if err != nil {
		if errors.Is(err, data.ErrAccountAlreadyExists) {
			return nil, &gqlerror.Error{
				Message: ErrMsgAccountAlreadyExists,
				Extensions: map[string]interface{}{
					"code": "ACCOUNT_ALREADY_EXISTS",
				},
			}
		}
		if errors.Is(err, services.ErrInvalidAddress) {
			return nil, &gqlerror.Error{
				Message: ErrMsgInvalidAddress,
				Extensions: map[string]interface{}{
					"code": "INVALID_ADDRESS",
				},
			}
		}
		return nil, &gqlerror.Error{
			Message: fmt.Sprintf(ErrMsgAccountRegistrationFailed, err.Error()),
			Extensions: map[string]interface{}{
				"code": "ACCOUNT_REGISTRATION_FAILED",
			},
		}
	}

	// Return the account data directly since we know the address
	account := &types.Account{
		StellarAddress: types.AddressBytea(input.Address),
		CreatedAt:      time.Now(),
	}

	return &graphql1.RegisterAccountPayload{
		Success: true,
		Account: account,
	}, nil
}

// DeregisterAccount is the resolver for the deregisterAccount field.
func (r *mutationResolver) DeregisterAccount(ctx context.Context, input graphql1.DeregisterAccountInput) (*graphql1.DeregisterAccountPayload, error) {
	err := r.accountService.DeregisterAccount(ctx, input.Address)
	if err != nil {
		if errors.Is(err, data.ErrAccountNotFound) {
			return nil, &gqlerror.Error{
				Message: ErrMsgAccountNotFound,
				Extensions: map[string]interface{}{
					"code": "ACCOUNT_NOT_FOUND",
				},
			}
		}
		return nil, &gqlerror.Error{
			Message: fmt.Sprintf(ErrMsgAccountDeregistrationFailed, err.Error()),
			Extensions: map[string]interface{}{
				"code": "ACCOUNT_DEREGISTRATION_FAILED",
			},
		}
	}

	return &graphql1.DeregisterAccountPayload{
		Success: true,
		Message: &[]string{ErrMsgAccountDeregisteredSuccess}[0],
	}, nil
}

// BuildTransaction is the resolver for the buildTransaction field.
func (r *mutationResolver) BuildTransaction(ctx context.Context, input graphql1.BuildTransactionInput) (*graphql1.BuildTransactionPayload, error) {
	genericTx, err := txnbuild.TransactionFromXDR(input.TransactionXdr)
	if err != nil {
		return nil, &gqlerror.Error{
			Message: ErrMsgCouldNotParseTransactionEnvelope,
			Extensions: map[string]any{
				"code": "INVALID_TRANSACTION_XDR",
			},
		}
	}

	// Convert simulation result if provided
	var simulationResult *entities.RPCSimulateTransactionResult
	if input.SimulationResult != nil {
		convertedSimulationResult, err := convertSimulationResult(input.SimulationResult)
		if err != nil {
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]any{
					"code": "INVALID_SIMULATION_RESULT",
				},
			}
		}
		simulationResult = &convertedSimulationResult
	}

	// Build transaction from XDR with optional simulation result
	tx, err := r.transactionService.BuildAndSignTransactionWithChannelAccount(ctx, genericTx, simulationResult)
	if err != nil {
		switch {
		case errors.Is(err, services.ErrInvalidTimeout),
			errors.Is(err, services.ErrInvalidOperationChannelAccount),
			errors.Is(err, services.ErrInvalidOperationMissingSource):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]any{
					"code": "INVALID_OPERATION_STRUCTURE",
				},
			}
		case errors.Is(err, services.ErrInvalidSorobanOperationCount),
			errors.Is(err, services.ErrInvalidSorobanSimulationEmpty),
			errors.Is(err, services.ErrInvalidSorobanSimulationFailed),
			errors.Is(err, services.ErrInvalidSorobanOperationType),
			errors.Is(err, services.ErrInvalidSorobanSimulationResultsEmpty):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]any{
					"code": "INVALID_SOROBAN_TRANSACTION",
				},
			}
		case errors.Is(err, signing.ErrUnavailableChannelAccounts), errors.Is(err, store.ErrNoIdleChannelAccountAvailable):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]any{
					"code": "CHANNEL_ACCOUNT_UNAVAILABLE",
				},
			}
		case errors.Is(err, sorobanauth.ErrForbiddenSigner):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]any{
					"code": "FORBIDDEN_SIGNER",
				},
			}
		default:
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]any{
					"code": "TRANSACTION_BUILD_FAILED",
				},
			}
		}
	}

	// Convert transaction to XDR string
	txXdrStr, _ := tx.Base64()

	return &graphql1.BuildTransactionPayload{
		Success:        true,
		TransactionXdr: txXdrStr,
	}, nil
}

// CreateFeeBumpTransaction is the resolver for the createFeeBumpTransaction field.
func (r *mutationResolver) CreateFeeBumpTransaction(ctx context.Context, input graphql1.CreateFeeBumpTransactionInput) (*graphql1.CreateFeeBumpTransactionPayload, error) {
	genericTx, err := txnbuild.TransactionFromXDR(input.TransactionXdr)
	if err != nil {
		return nil, &gqlerror.Error{
			Message: ErrMsgCouldNotParseTransactionEnvelope,
			Extensions: map[string]any{
				"code": "INVALID_TRANSACTION_XDR",
			},
		}
	}

	_, ok := genericTx.FeeBump()
	if ok {
		return nil, &gqlerror.Error{
			Message: ErrMsgCannotWrapFeeBumpTransaction,
			Extensions: map[string]any{
				"code": "FEE_BUMP_TX_NOT_ALLOWED",
			},
		}
	}

	tx, ok := genericTx.Transaction()
	if !ok {
		return nil, &gqlerror.Error{
			Message: ErrMsgInvalidTransaction,
			Extensions: map[string]any{
				"code": "INVALID_TRANSACTION",
			},
		}
	}

	feeBumpTxe, networkPassphrase, err := r.feeBumpService.WrapTransaction(ctx, tx)
	if err != nil {
		switch {
		case errors.Is(err, services.ErrFeeExceedsMaximumBaseFee):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]any{
					"code":           "FEE_EXCEEDS_MAXIMUM",
					"maximumBaseFee": r.feeBumpService.GetMaximumBaseFee(),
				},
			}
		case errors.Is(err, services.ErrNoSignaturesProvided):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]any{
					"code": "NO_SIGNATURES_PROVIDED",
				},
			}
		case errors.Is(err, services.ErrAccountNotEligibleForBeingSponsored):
			return nil, &gqlerror.Error{
				Message: err.Error(),
				Extensions: map[string]any{
					"code": "ACCOUNT_NOT_ELIGIBLE_FOR_BEING_SPONSORED",
				},
			}
		default:
			return nil, &gqlerror.Error{
				Message: fmt.Sprintf(ErrMsgFeeBumpCreationFailed, err.Error()),
				Extensions: map[string]any{
					"code": "FEE_BUMP_CREATION_FAILED",
				},
			}
		}
	}

	return &graphql1.CreateFeeBumpTransactionPayload{
		Success:           true,
		Transaction:       feeBumpTxe,
		NetworkPassphrase: networkPassphrase,
	}, nil
}

// Mutation returns graphql1.MutationResolver implementation.
func (r *Resolver) Mutation() graphql1.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
