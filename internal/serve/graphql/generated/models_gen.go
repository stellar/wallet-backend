// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/stellar/wallet-backend/internal/indexer/types"
)

type BaseStateChange interface {
	IsBaseStateChange()
	GetType() types.StateChangeCategory
	GetReason() types.StateChangeReason
	GetIngestedAt() time.Time
	GetLedgerCreatedAt() time.Time
	GetLedgerNumber() uint32
	GetAccount() *types.Account
	GetOperation() *types.Operation
	GetTransaction() *types.Transaction
}

type BuildTransactionInput struct {
	Transaction *TransactionInput `json:"transaction"`
}

type BuildTransactionPayload struct {
	Success        bool   `json:"success"`
	TransactionXdr string `json:"transactionXdr"`
}

type CreateFeeBumpTransactionInput struct {
	TransactionXdr string `json:"transactionXDR"`
}

type CreateFeeBumpTransactionPayload struct {
	Success           bool   `json:"success"`
	Transaction       string `json:"transaction"`
	NetworkPassphrase string `json:"networkPassphrase"`
}

type DeregisterAccountInput struct {
	Address string `json:"address"`
}

type DeregisterAccountPayload struct {
	Success bool    `json:"success"`
	Message *string `json:"message,omitempty"`
}

type LedgerBoundsInput struct {
	MinLedger *int32 `json:"minLedger,omitempty"`
	MaxLedger *int32 `json:"maxLedger,omitempty"`
}

type MemoInput struct {
	Type    MemoType `json:"type"`
	Text    *string  `json:"text,omitempty"`
	ID      *string  `json:"id,omitempty"`
	Hash    *string  `json:"hash,omitempty"`
	RetHash *string  `json:"retHash,omitempty"`
}

type Mutation struct {
}

type OperationConnection struct {
	Edges    []*OperationEdge `json:"edges,omitempty"`
	PageInfo *PageInfo        `json:"pageInfo"`
}

type OperationEdge struct {
	Node   *types.Operation `json:"node,omitempty"`
	Cursor string           `json:"cursor"`
}

type PageInfo struct {
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
}

type PreconditionsInput struct {
	TimeBounds      *TimeBoundsInput   `json:"timeBounds,omitempty"`
	LedgerBounds    *LedgerBoundsInput `json:"ledgerBounds,omitempty"`
	MinSeqNum       *string            `json:"minSeqNum,omitempty"`
	MinSeqAge       *string            `json:"minSeqAge,omitempty"`
	MinSeqLedgerGap *int32             `json:"minSeqLedgerGap,omitempty"`
	ExtraSigners    []string           `json:"extraSigners,omitempty"`
}

type Query struct {
}

type RegisterAccountInput struct {
	Address string `json:"address"`
}

type RegisterAccountPayload struct {
	Success bool           `json:"success"`
	Account *types.Account `json:"account,omitempty"`
}

type SimulationResultInput struct {
	TransactionData *string  `json:"transactionData,omitempty"`
	Events          []string `json:"events,omitempty"`
	MinResourceFee  *string  `json:"minResourceFee,omitempty"`
	Results         []string `json:"results,omitempty"`
	LatestLedger    *int32   `json:"latestLedger,omitempty"`
	Error           *string  `json:"error,omitempty"`
}

type StateChangeConnection struct {
	Edges    []*StateChangeEdge `json:"edges,omitempty"`
	PageInfo *PageInfo          `json:"pageInfo"`
}

type StateChangeEdge struct {
	Node   BaseStateChange `json:"node,omitempty"`
	Cursor string          `json:"cursor"`
}

type TimeBoundsInput struct {
	MinTime *string `json:"minTime,omitempty"`
	MaxTime *string `json:"maxTime,omitempty"`
}

type TransactionConnection struct {
	Edges    []*TransactionEdge `json:"edges,omitempty"`
	PageInfo *PageInfo          `json:"pageInfo"`
}

type TransactionEdge struct {
	Node   *types.Transaction `json:"node,omitempty"`
	Cursor string             `json:"cursor"`
}

type TransactionInput struct {
	Operations       []string               `json:"operations"`
	Timeout          int32                  `json:"timeout"`
	Memo             *MemoInput             `json:"memo,omitempty"`
	Preconditions    *PreconditionsInput    `json:"preconditions,omitempty"`
	SimulationResult *SimulationResultInput `json:"simulationResult,omitempty"`
}

type MemoType string

const (
	MemoTypeMemoNone   MemoType = "MEMO_NONE"
	MemoTypeMemoText   MemoType = "MEMO_TEXT"
	MemoTypeMemoID     MemoType = "MEMO_ID"
	MemoTypeMemoHash   MemoType = "MEMO_HASH"
	MemoTypeMemoReturn MemoType = "MEMO_RETURN"
)

var AllMemoType = []MemoType{
	MemoTypeMemoNone,
	MemoTypeMemoText,
	MemoTypeMemoID,
	MemoTypeMemoHash,
	MemoTypeMemoReturn,
}

func (e MemoType) IsValid() bool {
	switch e {
	case MemoTypeMemoNone, MemoTypeMemoText, MemoTypeMemoID, MemoTypeMemoHash, MemoTypeMemoReturn:
		return true
	}
	return false
}

func (e MemoType) String() string {
	return string(e)
}

func (e *MemoType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MemoType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MemoType", str)
	}
	return nil
}

func (e MemoType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MemoType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MemoType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
