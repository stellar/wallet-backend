package sorobanauth

import (
	"errors"
	"fmt"
	"slices"

	"github.com/stellar/go-stellar-sdk/hash"
	"github.com/stellar/go-stellar-sdk/keypair"
	"github.com/stellar/go-stellar-sdk/network"
	"github.com/stellar/go-stellar-sdk/strkey"
	"github.com/stellar/go-stellar-sdk/xdr"

	"github.com/stellar/wallet-backend/internal/entities"
)

var ErrForbiddenSigner = errors.New("the provided operation relies on a forbidden signer")

type UnsupportedCredentialsTypeError struct {
	CredentialsType xdr.SorobanCredentialsType
}

func (e *UnsupportedCredentialsTypeError) Error() string {
	return fmt.Sprintf("unsupported credentials type %d-%q", e.CredentialsType, e.CredentialsType.String())
}

type AuthSigner struct {
	NetworkPassphrase string
}

// AuthorizeEntry authorizes a soroban auth entry with a signature generated by the given keypair. It returns an error
// if the entry is not address-based.
func (s *AuthSigner) AuthorizeEntry(auth xdr.SorobanAuthorizationEntry, nonce int64, validUntilLedgerSeq uint32, signer *keypair.Full) (xdr.SorobanAuthorizationEntry, error) {
	if auth.Credentials.Type != xdr.SorobanCredentialsTypeSorobanCredentialsAddress {
		return auth, &UnsupportedCredentialsTypeError{CredentialsType: auth.Credentials.Type}
	}

	// 1: soroban auth entry
	entry := xdr.SorobanAuthorizationEntry{
		RootInvocation: auth.RootInvocation,
		Credentials: xdr.SorobanCredentials{
			Type: auth.Credentials.Type,
			Address: &xdr.SorobanAddressCredentials{
				Address:                   auth.Credentials.Address.Address,
				Nonce:                     xdr.Int64(nonce),
				SignatureExpirationLedger: xdr.Uint32(validUntilLedgerSeq),
				Signature:                 xdr.ScVal{}, // will be replaced
			},
		},
	}

	// 2: build preimage
	addrAuth := entry.Credentials.Address

	preimage := xdr.HashIdPreimage{
		Type: xdr.EnvelopeTypeEnvelopeTypeSorobanAuthorization,
		SorobanAuthorization: &xdr.HashIdPreimageSorobanAuthorization{
			NetworkId:                 network.ID(s.NetworkPassphrase),
			Nonce:                     addrAuth.Nonce,
			Invocation:                entry.RootInvocation,
			SignatureExpirationLedger: addrAuth.SignatureExpirationLedger,
		},
	}
	preimageBytes, err := preimage.MarshalBinary()
	if err != nil {
		return xdr.SorobanAuthorizationEntry{}, fmt.Errorf("marshalling preimage: %w", err)
	}
	payload := hash.Hash(preimageBytes)

	// 3: Produce signature
	scSignature, err := s.signScVal(signer, payload)
	if err != nil {
		return xdr.SorobanAuthorizationEntry{}, fmt.Errorf("signing payload: %w", err)
	}

	// 4: Update the auth entry with the signature
	addrAuth.Signature = scSignature

	return entry, nil
}

func (s *AuthSigner) signScVal(signer *keypair.Full, payload [32]byte) (xdr.ScVal, error) {
	// 1: Sign the payload
	signature, err := signer.Sign(payload[:])
	publicKey := signer.Address()
	if err != nil {
		return xdr.ScVal{}, fmt.Errorf("signing payload: %w", err)
	}

	// 2: Create the signature object for the auth entry
	pubKeyBytes, err := strkey.Decode(strkey.VersionByteAccountID, publicKey)
	if err != nil {
		return xdr.ScVal{}, fmt.Errorf("decoding public key: %w", err)
	}
	scSignature := xdr.ScVal{
		Type: xdr.ScValTypeScvVec,
		Vec: ptr(&xdr.ScVec{
			xdr.ScVal{
				Type: xdr.ScValTypeScvMap,
				Map: ptr(&xdr.ScMap{
					xdr.ScMapEntry{
						Key: xdr.ScVal{
							Type: xdr.ScValTypeScvSymbol,
							Sym:  ptr(xdr.ScSymbol("public_key")),
						},
						Val: xdr.ScVal{
							Type:  xdr.ScValTypeScvBytes,
							Bytes: ptr(xdr.ScBytes(pubKeyBytes)),
						},
					},
					xdr.ScMapEntry{
						Key: xdr.ScVal{
							Type: xdr.ScValTypeScvSymbol,
							Sym:  ptr(xdr.ScSymbol("signature")),
						},
						Val: xdr.ScVal{
							Type:  xdr.ScValTypeScvBytes,
							Bytes: ptr(xdr.ScBytes(signature)),
						},
					},
				}),
			},
		}),
	}

	return scSignature, nil
}

// ptr returns a pointer to the given value of any type.
func ptr[T any](v T) *T {
	return &v
}

// CheckForForbiddenSigners checks if the auth entries in the simulation response expect a forbidden signer.
func CheckForForbiddenSigners(
	simulationResponseResults []entities.RPCSimulateHostFunctionResult,
	opSourceAccount string,
	forbiddenSigners ...string,
) error {
	for _, res := range simulationResponseResults {
		for _, auth := range res.Auth {
			switch auth.Credentials.Type {
			case xdr.SorobanCredentialsTypeSorobanCredentialsSourceAccount:
				if slices.Contains(append(forbiddenSigners, ""), opSourceAccount) {
					return fmt.Errorf("handling %s: %w", auth.Credentials.Type.String(), ErrForbiddenSigner)
				}

			case xdr.SorobanCredentialsTypeSorobanCredentialsAddress:
				if auth.Credentials.Address == nil {
					return fmt.Errorf("unable to get auth entry signer because credential address is nil")
				} else if authEntrySigner, err := auth.Credentials.Address.Address.String(); err != nil {
					return fmt.Errorf("unable to get auth entry signer string: %w", err)
				} else if slices.Contains(forbiddenSigners, authEntrySigner) {
					return fmt.Errorf("handling %s: %w", auth.Credentials.Type.String(), ErrForbiddenSigner)
				}

			default:
				return fmt.Errorf("unsupported auth entry type %d", auth.Credentials.Type)
			}
		}
	}
	return nil
}
